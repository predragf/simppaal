package org.fmaes.simulinktotimedautomata.platformextender.blockroutinegenerator.ratetransition;

import java.util.Iterator;

import org.fmaes.simulinktotimedautomata.blockroutinegenerator.BlockRoutineGeneratorInterface;
import org.fmaes.simulinktotimedautomata.types.wrappers.Neighbour;
import org.fmaes.simulinktotimedautomata.types.wrappers.SimulinkBlockWrapper;

public class RateTransition implements BlockRoutineGeneratorInterface {

  @Override
  public String generateBlockRoutine(SimulinkBlockWrapper blockForParsing) {
    // TODO Auto-generated method stub
    return null;
  }

  @Override
  public String generateSignalDeclaration(SimulinkBlockWrapper blockForParsing) {
    // TODO Auto-generated method stub
    return null;
  }

  private int determineOperationType(SimulinkBlockWrapper blockForParsing) {
    Integer inPtsNum, outPtsNum;
    inPtsNum = outPtsNum = null;
    int operationType = OperationTypesEnum.ERROR;
    boolean deterministic, dataIntegrity;
    String deterministicParam = blockForParsing.getDeclaredParameter("Deterministic");
    String dataIntegrityParam = blockForParsing.getDeclaredParameter("Integrity");
    deterministic =
        deterministicParam != null && deterministicParam.trim().toLowerCase().equals("on");
    dataIntegrity =
        dataIntegrityParam != null && !dataIntegrityParam.trim().toLowerCase().equals("on");

    PortData inportData = findInportData(blockForParsing);
    PortData outportData = findOutportData(blockForParsing);

    String outPortSampleTimeOpt = blockForParsing.getDeclaredParameter("OutPortSampleTimeOpt");
    if (outPortSampleTimeOpt.trim().equals("Multiple of input port sample time")) {
      String outPts = blockForParsing.getDeclaredParameter("OutPortSampleTimeMultiple");
      try {
        outPtsNum = Integer.parseInt(outPts);
        if (inPtsNum != null) {
          outportData.ts = inportData.ts * outPtsNum;
        }
      } catch (Exception e) {
        // TODO: handle exception
        outportData.ts = -1.0;
      }
    }

    if ((deterministic || dataIntegrity) && (inportData.ts == outportData.ts)
        && (inportData.offset == outportData.offset)) {
      operationType = OperationTypesEnum.COPY;
    }

    if (dataIntegrity && !deterministic && ((inportData.ts == outportData.ts)
        && (inportData.offset < outportData.offset)
        || (inportData.ts < outportData.ts
            && (((inportData.offset == 0.0 && outportData.offset == 0.0)
                && (inportData.ts > outportData.ts) && ((outportData.ts % inportData.ts) == 0.0))
                || ((inportData.offset <= outportData.offset) && (inportData.ts > outportData.ts)
                    && ((outportData.ts % inportData.ts) == 0.0)))))) {
      operationType = OperationTypesEnum.BUFF;
    }

    if ((dataIntegrity && !deterministic)
        && ((inportData.ts > outportData.ts) && dataIntegrity && !deterministic)
        || ((inportData.ts < outportData.ts) && ((outportData.ts % inportData.ts) != 0.0))
        || ((inportData.ts < outportData.ts) && (inportData.offset > outportData.offset))) {
      operationType = OperationTypesEnum.DB_BUFF;
    }

    if ((inportData.ts < outportData.ts) && (inportData.offset == outportData.offset)
        && (inportData.offset == 0.0) && (outportData.ts % inportData.ts == 0.0))

      return operationType;
  }

  @Override
  public String generateInitRoutine(SimulinkBlockWrapper blockForParsing) {
    // TODO Auto-generated method stub
    return null;
  }

  @Override
  public String generateDeclaration(SimulinkBlockWrapper blockForParsing) {
    // TODO Auto-generated method stub
    return null;
  }


  private PortData findInportData(SimulinkBlockWrapper rt) {
    PortData inportData = new PortData();
    double inportSampleTime = -1;
    double inportOffset = 0;
    Neighbour predecessor = rt.getPredecessorAtPosition(0);
    if (predecessor.getSimulinkBlock().exists()) {
      String ts = predecessor.getSimulinkBlock().getSampleTime();
      String offset = predecessor.getSimulinkBlock().getDeclaredParameter("Offset");
      try {
        inportSampleTime = Double.parseDouble(ts);
      } catch (Exception e) {
        // TODO: handle exception
        inportSampleTime = -1;
      }

      try {
        inportOffset = Double.parseDouble(offset);
      } catch (Exception e) {
        // TODO: handle exception
        inportOffset = 0;
      }
    }
    inportData.offset = inportOffset;
    inportData.ts = inportSampleTime;
    return inportData;
  }

  private PortData findOutportData(SimulinkBlockWrapper rt) {
    double outPortSampleTime = -1;
    double outportoffset = 0;

    for (Neighbour successor : rt.getSuccessors()) {
      double currentSucTs = -1;
      if (successor.getSimulinkBlock().exists()) {
        String ts = successor.getSimulinkBlock().getSampleTime();
        try {
          outPortSampleTime = Double.parseDouble(ts);
        } catch (Exception e) {
          // TODO: handle exception
          currentSucTs = -1;
        }
        if ((outPortSampleTime == -1 && currentSucTs != -1)
            || (outPortSampleTime != -1 && currentSucTs < outPortSampleTime)) {
          outPortSampleTime = currentSucTs;
          String offset = successor.getSimulinkBlock().getDeclaredParameter("Offset");
          try {
            outportoffset = Double.parseDouble(offset);
          } catch (Exception e) {
            // TODO: handle exception
            outportoffset = 0;
          }
        }
      }
    }
    return new PortData(outPortSampleTime, outportoffset);
  }
}
