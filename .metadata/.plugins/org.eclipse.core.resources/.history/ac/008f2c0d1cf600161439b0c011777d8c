package org.fmaes.simulinktotimedautomata.parsers;

import org.fmaes.simulinktotimedautomata.types.wrappers.SimulinkLineWrapper;
import org.fmaes.simulinktotimedautomata.types.wrappers.SimulinkModelWrapper;
import org.fmaes.simulinktotimedautomata.types.wrappers.SimulinkPortBaseWrapper;
import org.fmaes.simulinktotimedautomata.util.Util;

import java.util.ArrayList;
import java.util.Collection;

import org.conqat.lib.simulink.model.SimulinkPortBase;
import org.fmaes.simulinktotimedautomata.types.enums.SimulinkBlockTypesEnum;
import org.fmaes.simulinktotimedautomata.types.enums.SimulinkDeclaredParametersEnum;
import org.fmaes.simulinktotimedautomata.types.wrappers.Predecessor;
import org.fmaes.simulinktotimedautomata.types.wrappers.SimulinkBlockWrapper;

public class SimulinkLineParser {

  public static Collection<Predecessor> parseLine(SimulinkLineWrapper lineForParsing,
      String lastDemuxPort) {
    Collection<Predecessor> predecessors = new ArrayList<Predecessor>();
    SimulinkBlockWrapper lineSourceBlock = lineForParsing.getSourceBlock();
    SimulinkPortBaseWrapper lineSourcePort = lineForParsing.getSourcePort();
    Collection<SimulinkLineWrapper> linesForParsing = new ArrayList<SimulinkLineWrapper>();
    if (lineSourceBlock.isAtomic() && lineSourceBlock.isComputational()
        && !Util.matchStringsIgnoreCase(lineSourceBlock.getType(),
            SimulinkBlockTypesEnum.INPORT.toString())) {
      Predecessor predecessor = new Predecessor();
      predecessor.setSimulinkBlock(lineSourceBlock);
      predecessors.add(predecessor);
    } else if (!lineSourceBlock.isComputational()
        && lineSourceBlock.getType().toLowerCase().equals("mux")) {
      Collection<SimulinkLineWrapper> muxlines;
      if (Util.isNumber(lastDemuxPort)) {
        muxlines = lineSourceBlock.getIncomingLinesByPortIndex(lastDemuxPort);
      } else {
        muxlines = lineSourceBlock.getIncomingLines();
      }
      predecessors.addAll(parseLines(muxlines, ""));
    } else if (!lineSourceBlock.isComputational()
        && lineSourceBlock.getType().toLowerCase().equals("demux")) {
      String demuxPort = lineSourcePort.getPortIndex();
      predecessors.addAll(parseLines(lineSourceBlock.getIncomingLines(), demuxPort));
    } else if (Util.matchStringsIgnoreCase("from", lineSourceBlock.getType())) {
      SimulinkBlockWrapper matchingGoto = mapFromToGoto(lineSourceBlock);
      if (matchingGoto.exists()) {
        linesForParsing.addAll(matchingGoto.getIncomingLines());
      }
    } else if (Util.matchStringsIgnoreCase("goto", lineSourceBlock.getType())) {
      linesForParsing.addAll(lineSourceBlock.getIncomingLines());
    } else if (lineSourceBlock.isAtomic() && !lineSourceBlock.isComputational()
        && !Util.matchStringsIgnoreCase(lineSourceBlock.getType(),
            SimulinkBlockTypesEnum.INPORT.toString())) {
      linesForParsing.addAll(lineSourceBlock.getIncomingLines());
    } else if (lineSourceBlock.isAtomic() && lineSourceBlock.isComputational()
        && Util.matchStringsIgnoreCase(lineSourceBlock.getType(),
            SimulinkBlockTypesEnum.INPORT.toString())) {
      SimulinkBlockWrapper compositeParentBlock = lineSourceBlock.getParentSimulinkBlock();
      String portIndex =
          lineSourceBlock.getDeclaredParameter(SimulinkDeclaredParametersEnum.PORT.toString());
      portIndex = Util.convertToPortIndex(portIndex);
      /*
       * Dirty fix for inports on root model. if there are no input lines from the inport, then just
       * add the port
       */
      Collection<SimulinkLineWrapper> inportLines =
          compositeParentBlock.getIncomingLinesByPortIndex(portIndex);
      linesForParsing.addAll(inportLines);
      if (inportLines.size() == 0) {
        Predecessor pred = new Predecessor();
        pred.setSimulinkBlock(lineSourceBlock);
        pred.setToPort(lineSourcePort);
        predecessors.add(pred);
      }
    } else if (lineSourceBlock.getType().toLowerCase().equals("reference") && !Util
        .matchStringsIgnoreCase(lineSourceBlock.getDeclaredParameter("SourceType"), "subsystem")) {
      /* This case is masked block */
      Predecessor pred = new Predecessor();
      pred.setSimulinkBlock(lineSourceBlock);
      pred.setToPort(lineForParsing.getDestinationPort());
      predecessors.add(pred);
    } else if (lineSourceBlock.isSubsystem() || lineSourceBlock.isLibrary()) {
      String sourcePortIndex = lineSourcePort.getPortIndex();
      sourcePortIndex = Util.convertToPortIndex(sourcePortIndex);
      SimulinkBlockWrapper internalPortBlock =
          lineSourceBlock.getInternalPortBlockByIndex(sourcePortIndex);
      linesForParsing.addAll(internalPortBlock.getIncomingLines());
    }
    predecessors.addAll(SimulinkLineParser.parseLines(linesForParsing, lastDemuxPort));
    return predecessors;
  }

  public static Collection<Predecessor> parseLineForward(SimulinkLineWrapper lineForParsing,
      String lastMuxPort) {
    Collection<Predecessor> successors = new ArrayList<Predecessor>();
    SimulinkBlockWrapper lineDestinationBlock = lineForParsing.getDestinationBlock();
    SimulinkPortBaseWrapper lineSourcePort = lineForParsing.getSourcePort();
    Collection<SimulinkLineWrapper> linesForParsing = new ArrayList<SimulinkLineWrapper>();
    if (lineSourceBlock.isAtomic() && lineSourceBlock.isComputational()
        && !Util.matchStringsIgnoreCase(lineSourceBlock.getType(),
            SimulinkBlockTypesEnum.INPORT.toString())) {
      Predecessor predecessor = new Predecessor();
      predecessor.setSimulinkBlock(lineSourceBlock);
      predecessors.add(predecessor);
    } else if (!lineSourceBlock.isComputational()
        && lineSourceBlock.getType().toLowerCase().equals("mux")) {
      Collection<SimulinkLineWrapper> muxlines;
      if (Util.isNumber(lastDemuxPort)) {
        muxlines = lineSourceBlock.getIncomingLinesByPortIndex(lastDemuxPort);
      } else {
        muxlines = lineSourceBlock.getIncomingLines();
      }
      predecessors.addAll(parseLines(muxlines, ""));
    } else if (!lineSourceBlock.isComputational()
        && lineSourceBlock.getType().toLowerCase().equals("demux")) {
      String demuxPort = lineSourcePort.getPortIndex();
      predecessors.addAll(parseLines(lineSourceBlock.getIncomingLines(), demuxPort));
    } else if (Util.matchStringsIgnoreCase("from", lineSourceBlock.getType())) {
      SimulinkBlockWrapper matchingGoto = mapFromToGoto(lineSourceBlock);
      if (matchingGoto.exists()) {
        linesForParsing.addAll(matchingGoto.getIncomingLines());
      }
    } else if (Util.matchStringsIgnoreCase("goto", lineSourceBlock.getType())) {
      linesForParsing.addAll(lineSourceBlock.getIncomingLines());
    } else if (lineSourceBlock.isAtomic() && !lineSourceBlock.isComputational()
        && !Util.matchStringsIgnoreCase(lineSourceBlock.getType(),
            SimulinkBlockTypesEnum.INPORT.toString())) {
      linesForParsing.addAll(lineSourceBlock.getIncomingLines());
    } else if (lineSourceBlock.isAtomic() && lineSourceBlock.isComputational()
        && Util.matchStringsIgnoreCase(lineSourceBlock.getType(),
            SimulinkBlockTypesEnum.INPORT.toString())) {
      SimulinkBlockWrapper compositeParentBlock = lineSourceBlock.getParentSimulinkBlock();
      String portIndex =
          lineSourceBlock.getDeclaredParameter(SimulinkDeclaredParametersEnum.PORT.toString());
      portIndex = Util.convertToPortIndex(portIndex);
      /*
       * Dirty fix for inports on root model. if there are no input lines from the inport, then just
       * add the port
       */
      Collection<SimulinkLineWrapper> inportLines =
          compositeParentBlock.getIncomingLinesByPortIndex(portIndex);
      linesForParsing.addAll(inportLines);
      if (inportLines.size() == 0) {
        Predecessor pred = new Predecessor();
        pred.setSimulinkBlock(lineSourceBlock);
        pred.setToPort(lineSourcePort);
        predecessors.add(pred);
      }
    } else if (lineSourceBlock.getType().toLowerCase().equals("reference") && !Util
        .matchStringsIgnoreCase(lineSourceBlock.getDeclaredParameter("SourceType"), "subsystem")) {
      /* This case is masked block */
      Predecessor pred = new Predecessor();
      pred.setSimulinkBlock(lineSourceBlock);
      pred.setToPort(lineForParsing.getDestinationPort());
      predecessors.add(pred);
    } else if (lineSourceBlock.isSubsystem() || lineSourceBlock.isLibrary()) {
      String sourcePortIndex = lineSourcePort.getPortIndex();
      sourcePortIndex = Util.convertToPortIndex(sourcePortIndex);
      SimulinkBlockWrapper internalPortBlock =
          lineSourceBlock.getInternalPortBlockByIndex(sourcePortIndex);
      linesForParsing.addAll(internalPortBlock.getIncomingLines());
    }
    predecessors.addAll(SimulinkLineParser.parseLines(linesForParsing, lastDemuxPort));
    return predecessors;
  }


  public static Collection<Predecessor> parseLines(Collection<SimulinkLineWrapper> linesForParsing,
      String startPortIndex) {
    Collection<Predecessor> predecessors = new ArrayList<Predecessor>();
    for (SimulinkLineWrapper lineForParsing : linesForParsing) {
      predecessors.addAll(parseLine(lineForParsing, startPortIndex));
    }
    return predecessors;
  }

  public static Collection<Predecessor> parseLinesForward(
      Collection<SimulinkLineWrapper> linesForParsing, String startPortIndex) {
    Collection<Predecessor> successors = new ArrayList<Predecessor>();
    for (SimulinkLineWrapper lineForParsing : linesForParsing) {
      successors.addAll(parseLine(lineForParsing, startPortIndex));
    }
    return successors;
  }

  public static SimulinkBlockWrapper mapFromToGoto(SimulinkBlockWrapper fromBlock) {
    SimulinkModelWrapper currentModel = fromBlock.getSimulinkModelWrapped();
    String gotoTag = fromBlock.getParameter("GotoTag");
    Collection<SimulinkBlockWrapper> allGotTos = currentModel.getChildBlocksByType("goto");
    SimulinkBlockWrapper matchingGoto = new SimulinkBlockWrapper(null);
    for (SimulinkBlockWrapper gotoBlock : allGotTos) {
      if (gotoBlock.exists()
          && Util.matchStringsIgnoreCase(gotoTag, gotoBlock.getDeclaredParameter("GotoTag"))) {
        matchingGoto = gotoBlock;
        break;
      }
    }
    return matchingGoto;
  }

  public static SimulinkBlockWrapper mapGotoToFrom(SimulinkBlockWrapper gotoBlock) {
    SimulinkModelWrapper currentModel = gotoBlock.getSimulinkModelWrapped();
    String gotoTag = gotoBlock.getParameter("GotoTag");
    Collection<SimulinkBlockWrapper> allFroms = currentModel.getChildBlocksByType("from");
    SimulinkBlockWrapper matchingFrom = new SimulinkBlockWrapper(null);
    for (SimulinkBlockWrapper fromBlock : allFroms) {
      if (fromBlock.exists()
          && Util.matchStringsIgnoreCase(gotoTag, fromBlock.getDeclaredParameter("GotoTag"))) {
        matchingFrom = fromBlock;
        break;
      }
    }
    return matchingFrom;
  }
}
